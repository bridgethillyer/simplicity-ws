(ns simplicity-deck.sample-code
    (:require [hoplon.reveal :refer [highlight]]))


(defn get-simple-ring-app []
  (highlight
    ;;{{
    (ns request-echo
      (:require [clojure.pprint :refer [pprint]]))

    (defn handler
      "Return the request as HTML."
      ;; A request comes in the handler.
      [request]

      ;; The handler returns a response map.
      {:status 200
       :headers {"Content-Type" "text/html"}
       :body (str "<h1>Request Echo</h1><pre>"
                  (with-out-str (pprint request))
                  "</pre>")})
    ;;}}
    ))

(defn call-a-function []
  (highlight
    ;;{{
    (println "Hello, friends!")
    ;;}}
    ))

(defn use-let []
  (highlight
    ;;{{
    (let [x 1
          y 2]
      (println "x + y = " (+ x y)))
    ;;}}
    ))

(defn define-with-defn []
  (highlight
    ;;{{
    (defn fun-fun 
      []
      (println "Hello from a function."))
    ;;}}
    ))

(defn show-map []
  (highlight
    ;;{{
    (map inc (range 1 10))
    ;;}}
    ))

(defn show-reduce []
  (highlight
    ;;{{
    (reduce + (range 1 10))
    ;;}}
    ))

(defn show-cond []
  (highlight
    ;;{{
    (cond
      )

    ;;}}
    ))

(defn show-if []
  (highlight
    ;;{{
    (if 
      )
    ;;}}
    ))

(defn show-loop []
  (highlight
    ;;{{
    (loop 
      )
    ;;}}
    ))

(defn show-doseq []
  (highlight
    ;;{{
    (doseq
      )
    ;;}}
    ))

(defn get-liberator-todo []
  (highlight
    ;;{{
    (defresource todos-resource
      :allowed-methods [:get :post]
      :available-media-types ["application/edn"]
      :handle-ok (fn [_] @todo-list)
      :post! (fn [{:keys [request]}]
                 (let [body (-> (:body request)
                                slurp
                                read-string)
                       new-todo (assoc body :id (new-id))]
                   (swap! todo-list conj new-todo)
                   {:todo new-todo}))
      :handle-created (fn [{:keys [todo]}] todo))
      ;;}}
  ))

(defn get-http-streaming []
  (highlight
    ;;{{
    (defn streaming-handler [request]
      (with-channel request channel
        (on-close channel (fn [status] (println "channel closed, " status)))
        (doseq [i (range 1 10)]
          (send! channel
                 (str "message #" i)
                 false) ; false -> don't close after send
          (Thread/sleep 200))
        (close channel)))
    ;;}}
    ))

(defn get-http-outstream-p1 []
  (highlight
    ;;{{
    (defn ch->outputstream [ch]
      (proxy [java.io.OutputStream] []
        (close [] (close ch))
        (write
          ([^bytes bs] ;; bytes of byte
            (send! ch (String. bs) false))
          ([^bytes bs off len]
            (send! ch (String. bs off len) false)))))

      (defn ch->writer [ch]
        (io/writer (ch->outputstream ch)))
    ;;}}
    ))

(defn get-http-outstream-p2 []
  (highlight
    ;;{{
      (defn stream-slice-query-json
        [request response resource]
        (let [resource (hal/json-representation resource)]
          (with-channel request ch
            (send! ch response false)
            (with-open [writer (ch->writer ch)]
              (json/generate-stream resource writer))
            (close ch))
          response))
    ;;}}
    ))

(defn get-http-websocket []
  (highlight
    ;;{{
    (defn ws-handler [request]
      (with-channel request channel
        (swap! channels conj channel)
        (println "channel opened: " channel)
        (on-close channel
                  (fn [status]
                    (swap! channels disj channel)
                    (println "channel closed: " channel " - " status)))
        (on-receive channel
                    (fn [data]
                      (println "data received: " data)
                      (doseq [chan (disj @channels channel)]
                        (println "sending data: " channel " - " data)
                        (send! chan data))))))
    ;;}}
    ))

