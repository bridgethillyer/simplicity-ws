(ns simplicity-deck.sample-code
    (:require [hoplon.reveal :refer [hlclj highlight]]))


(defn show-vectors []
  (hlclj
    ;;{{
    [1 2 3 4 5 6 7 8 9 10] 
    []
    ;;}}
    ))

(defn show-more-vectors []
  (hlclj :class "two-cols"
    ;;{{
    (vector? [3 6 9])
    ;=> true

    (associative? [3 6 9])
    ;=> true

    (sequential? [3 6 9])
    ;=> true

    (vector 3 6 9)
    ;=> [3 6 9]

    (conj [3 6] 9)
    ;=> [3 6 9]

    (count [3 6 9])
    ;=> 3

    (nth [3 6 9] 1)
    ;=> 6 

    (first [3 6 9])
    ;=> 3 
    ;;}}
    ))

(defn show-lists []
  (hlclj
    ;;{{
    (1 2 3 4 5 6 7 8 9 10) 
    ()
    ;;}}
    ))

(defn show-more-lists []
  (hlclj
    ;;{{
    (list? (list 1 2 3))
    ;=> true

    (sequential? (list 1 2 3))
    ;=> true

    (associative? (list 1 2 3))
    ;=> false

    (list 1 2 3)
    ;=> (1 2 3)

    (cons 3 (list 1 2))
    ;=> (3 1 2)

    (conj (list 1 2) 3)
    ;=> (3 1 2)

    (count (list 1 2 3))
    ;=> 3

    (first (list 1 2 3))
    ;=> 1

    (rest (list 1 2 3))
    ;=> (2 3)
    ;;}}
    ))

(defn show-maps []
  (hlclj
    ;;{{
    {:first-name "Eleanor"
     :last-name "Peacock"}
    {}
    ;;}}
    ))

(defn show-more-maps []
  (hlclj
    ;;{{
    (map? {:first "Eleanor" :last "Peacock"})
    ;=> true

    (get {:first "Eleanor" :last "Peacock"} :first)
    ;=> "Eleanor"

    (get {:first "Eleanor"} :last :MISS)
    ;=> :MISS

    (assoc {:first "Eleanor"} :last "Peacock")
    ;=> {:first "Eleanor", :last "Peacock"}

    (dissoc {:first "Eleanor" :last "Peacock"} :last)
    ;=> {:first "Eleanor"}

    (merge {:first "Eleanor"} {:last "Peacock"})
    ;=> {:first "Eleanor", :last "Peacock"}

    (count {:first "Eleanor" :last "Peacock"})
    ;=> 2

    (keys {:first "Eleanor" :last "Peacock"})
    ;=> (:first :last)

    (vals {:first "Eleanor" :last "Peacock"})
    ;=> ("Eleanor" "Peacock")
    ;;}}
    ))

(defn maps-as-functions []
  (hlclj
    ;;{{
    (:a {:a 1})
    ;=> 1
    (:b {:a 1})
    ;=> nil
    (:b {:a 1} :MISS)
    ;=> :MISS
    ;;}}
    ))

(defn show-sets []
  (hlclj
    ;;{{
    #{"Library" "Billiard Room" "Conservatory"}
    #{}
    ;;}}
    ))

(defn show-more-sets []
  (hlclj
    ;;{{
    (set? #{1 2})
    ;=> true
    
    (sequential? #{1 2}) 
    ;=> false 
    
    (associative?#{1 2}) 
    ;=> false
    
    (set [1 2 3])
    ;=> #{1 2 3}
    
    (conj #{1 2} 3)
    ;=> #{1 2 3}
    
    (count #{1 2 3})
    ;=> 3
    
    (disj #{1 2 3} 3) 
    ;=> #{1 2} 

    (contains?#{1 2} 1) 
    ;=> true
    
    (:a #{:a :b})
    ;=> :a
    ;;}}
    ))

(defn infinite-seq []
  (hlclj
   ;;{{
   (def integers (range))
   (take 10 integers)
   ; => (0 1 2 3 4 5 6 7 8 9)

   (def gregory-leibniz
     (map first
          (iterate
           (fn [[pi div]]
             [(if (= 1 (mod div 4))
                (+ pi (/ 4 div))
                (- pi (/ 4 div)))
              (+ div 2)]) [0.0 1])))
   (first (drop 100 gregory-leibniz))
   ; => ???
   ;;}}
   ))

(defn call-a-function []
  (hlclj
    ;;{{
    (println "Hello, friends!")
    (+ 1 2)
    (first (1 2 3))
    ;;}}
    ))

(defn use-let []
  (hlclj
    ;;{{
    (let [x 4]
      (* x 3))
    ;;=> 12

    (let [x 1
          y 2]
      (println x " + " y " = " (+ x y)))
    ;;}}
    ))

(defn define-with-defn []
  (hlclj
    ;;{{
    (def triple 
      (fn 
        [x]
        (* x 3)))

    (defn triple
      [x]
      (* x 3))
    ;;}}
    ))

(defn show-map []
  (hlclj
    ;;{{
    (map inc (range 1 10))    
    ;;=> (2 3 4 5 6 7 8 9 10)
    ;;}}
    ))

(defn show-reduce []
  (hlclj
    ;;{{
    (reduce + (range 1 10))
    ;;=> 45
    ;;}}
    ))

(defn show-reduce-max []
  (hlclj
    ;;{{
    ;;TODO: put something here
    ;;}}
    ))

(defn show-cond []
  (hlclj
    ;;{{
    (let [min-age 12]
      (cond
        (>= min-age 18) "Adult game"
        (>= min-age 8) "Family game"
        (>= min-age 3) "Children's game"
        :else "Toy, not a game"))
    ;=> "Family game"
    ;;}}
    ))

(defn truthiness []
  (hlclj
    ;;{{
    (true? true)
    ;=> true

    (false? false)
    ;=> true

    (nil? nil)
    ;=> true

    (true? 3)
    ;=> false

    (false? nil)
    ;=> false

    (true? (= 1 1))
    ;=> true
    ;;}}
    ))

(defn show-if []
  (hlclj
    ;;{{
    (if (> 3 1)
        "3 is greater than 1"
        "3 is not greater than 1")
    ;=> "3 is greater than 1"
    ;;}}
    ))

(defn show-loop []
  (hlclj
    ;;{{
    (loop [x 21]
      (when (> x 1)
        (println x)
        (recur (- x 3))))
    ;;}}
    ))

(defn show-doseq []
  (hlclj
    ;;{{
    (doseq [x [1 2 3]
            y [1 2 3]]
      (println (* x y)))
    ;;}}
    ))

(defn clue-model []
  (hlclj
    ;;{{
    {:name "Clue"
     :min-num-players   3
     :max-num-players   6
     :min-age           8
     :subdomain         "Family Games"
     :categories        ["Bluffing" "Deduction" "Murder/Mystery"]
    }
    ;;}}
    ))

(defn monopoly-model []
  (hlclj
    ;;{{
    {:name "Monopoly"
     :min-num-players   2
     :max-num-players   8 
     :min-age           8
     :subdomain         "Family Games"
     :categories        ["Economic" "Negotiation"]
    }
    ;;}}
    ))

(defn candy-land-model []
  (hlclj
    ;;{{
    {:name "Candy Land"
     :min-num-players   2 
     :max-num-players   4 
     :min-age           3 
     :subdomain         "Children's Games"
     :categories        ["Children's Game" "Racing"]
    }
    ;;}}
    ))

(defn catan-model []
  (hlclj
    ;;{{
    {:name "The Settlers of Catan"
     :min-num-players   3 
     :max-num-players   4 
     :min-age           10 
     :subdomain         "Strategy Games"
     :categories        ["Civilization" "Negotiation"]
    }
    ;;}}
    ))

(defn diplomacy-model []
  (hlclj
    ;;{{
    {:name "Diplomacy"
     :min-num-players   2 
     :max-num-players   7 
     :min-age           12 
     :subdomain         "Strategy Games"
     :categories        ["Bluffing" "Negotiation" "Political" "Post-Napoleonic"]
    }
    ;;}}
    ))

(defn board-games-model []
  (hlclj
    ;;{{
    (def clue {:name "Clue" ...})
    (def monopoly {:name "Monopoly" ...})
    ;; etc

    (def board-games #{clue monopoly candy-land apples-to-apples
                       settlers-of-catan dominion netrunner risk})
     
    ;; and, oh, so many more
    ;;}}
    ))

(defn player-model []
  (hlclj
    ;;{{
    (def dorian 
      {:first           "Dorian"
       :last            "Hayes"
       :age             12
       :fav-categories  ["Fantasy" "Humor"]
       :type            "Player"})
    ;;}}
    ))

(defn ref-example []
  (hlclj
    ;;{{
    (def bank (ref 0))
    (def bank-props (ref #{"Baltic" "Park Place" "Boardwalk"}))
    (def player (ref [{:money 1500
                       :props #{}}]))

    @bank
    ;=> 0
    @bank-props
    ;=> #{"Baltic" "Boardwalk" "Park Place"}
    @player
    ;=> [{:money 1500, :props #{}}]
     
    (defn buy-property
      [prop-name cost player-num]
      (dosync 
        (alter bank + cost)
        (alter player update-in [player-num :money] - cost)
        (alter bank-props disj prop-name)
        (alter player update-in [player-num :props] conj prop-name)))

    (buy-property "Baltic" 200 0)

    @bank
    ;=> 200
    @bank-props
    ;=> #{"Boardwalk" "Park Place"}
    @player
    ;=> [{:money 1300, :props #{"Baltic"}}]
    ;;}}
    ))

(defn atom-example []
  (hlclj
    ;;{{
    (def player1 (atom {:brick 0 :lumber 1 :wool 1 :grain 0 :ore 0}))
    (def player2 (atom {:brick 1 :lumber 0 :wool 1 :grain 0 :ore 0}))
    (def player3 (atom {:brick 1 :lumber 0 :wool 0 :grain 2 :ore 0}))

    (swap! player1 update-in [:lumber] inc)
    (swap! player2 update-in [:grain] + 2)
    (swap! player3 update-in [:grain] inc)

    @player1
    ;=> {:brick 0, :lumber 2, :wool 1, :grain 0, :ore 0}
    @player2
    ;=> {:brick 1, :lumber 0, :wool 1, :grain 2, :ore 0}
    @player3
    ;=> {:brick 1, :lumber 0, :wool 0, :grain 3, :ore 0}
    ;;}}
    ))

(defn agent-example []
  (hlclj
    ;;{{
    (def p1 (agent []))
    (def p2 (agent []))

    @p1
    ;=> []
    @p2
    ;=> []

    (send p1 conj [:A "Hol-Bel"] [:A "Kie-Hol"] [:A "Smy-Arm"] [:A "Bud-Ser"] [:A "Tun-Wes"] [:F "Nap-Tys"] [:F "Por-Spa"])
    (send p2 conj [:F "Nwy-StP"] [:F "Nth-Nwy"] [:A "Edi-Nth"] [:A "Ruh-Bur"] [:A "Bul-Rum"] [:A "Con-Bul"] [:F "Tri-Bud"] [:A "Wes-Mid"] [:F "TyS-Lyo"])

    @p1
    ;=> [[:A "Hol-Bel"] [:A "Kie-Hol"] [:A "Smy-Arm"] [:A "Bud-Ser"] [:A "Tun-Wes"] [:F "Nap-Tys"] [:F "Por-Spa"]]
    @p2
    ;=> [[:F "Nwy-StP"] [:F "Nth-Nwy"] [:A "Edi-Nth"] [:A "Ruh-Bur"] [:A "Bul-Rum"] [:A "Con-Bul"] [:F "Tri-Bud"] [:A "Wes-Mid"] [:F "TyS-Lyo"]]
    ;;}}
    ))

(defn var-example []
  (hlclj
    ;;{{
    (ns games)

    (def clue { ... })
    ;=> #'games/clue

    (def monopoly { ... })
    ;=> #'games/monopoly

    (def board-games #{ ... })
    ;=> #'games/board-games

    (defn suggest-game [games min-age] ... )
    ;=> #'games/suggest-game
    ;;}}
    ))

(defn show-namespaces []
  (hlclj
    ;;{{
    (ns foo.bar.baz-quuz)
    ;;}}
    ))  

(defn show-require []
  (hlclj
    ;;{{
    (ns my-ns
      (:require clojure.set))

    (clojure.set/union #{1 2} #{2 3 4}) 
    ;;=> #{1 2 3 4}

    (ns my-ns
      (:require clojure.set :as set))

    (set/union #{1 2} #{2 3 4}) 
    ;;=> #{1 2 3 4}
    ;;}}
    )) 
